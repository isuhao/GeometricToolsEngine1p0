// Geometric Tools LLC, Redmond WA 98052
// Copyright (c) 1998-2014
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
// File Version: 1.0.0 (2014/08/11)

#pragma once

#include "GTEngineDEF.h"
#include "GteVector.h"
#include "GteGaussianElimination.h"

namespace gte
{

template <int NumRows, int NumCols, typename Real>
class Matrix
{
public:
    // The default constructor, copy constructor, destructor, and
    // assignment operator are generated by the compiler.  The default
    // constructor does not initialize its data.  The default destructor is
    // not virtual.  This avoids the extra storage needed for the virtual
    // function table, and it allows for derived classes with specific
    // dimensions.  The derived classes add constructors for NumRows-by-NumCols
    // elements.  The base class destruction has no side effects, so
    // polymorphic destruction of an object behaves correctly.

    // Create special matrices.
    void MakeZero();  // All components are 0.

    // Member access for which the storage representation is transparent.  The
    // matrix entry in row r and column c is A(r,c).  The first operator()
    // returns a const reference rather than a Real value.  This supports
    // writing via standard file operations that require a const pointer to
    // data.
    inline Real const& operator()(int r, int c) const;
    inline Real& operator()(int r, int c);

    // Member access by rows or by columns.
    void SetRow(int r, Vector<NumCols,Real> const& vec);
    void SetCol(int c, Vector<NumRows,Real> const& vec);
    Vector<NumCols,Real> GetRow(int r) const;
    Vector<NumRows,Real> GetCol(int c) const;

    // Member access by 1-dimensional index.  NOTE: These accessors are
    // useful for the manipulation of matrix entries when it does not
    // matter whether storage is row-major or column-major.  Do not use
    // constructs such as M[c+NumCols*r] or M[r+NumRows*c] that expose the
    // storage convention.
    inline Real const& operator[](int i) const;
    inline Real& operator[](int i);

    // Comparisons for sorted containers and geometric ordering.
    bool operator==(Matrix const& mat) const;
    bool operator!=(Matrix const& mat) const;
    bool operator< (Matrix const& mat) const;
    bool operator<=(Matrix const& mat) const;
    bool operator> (Matrix const& mat) const;
    bool operator>=(Matrix const& mat) const;

    // Special matrices.
    static Matrix Zero();

protected:
    class Table
    {
    public:
        // Storage-order-independent element access as 2D array.
        inline Real const& operator()(int r, int c) const;
        inline Real& operator()(int r, int c);

        // Element access as 1D array.  Use this internally only when
        // the 2D storage order is not relevant.
        inline Real const& operator[](int i) const;
        inline Real& operator[](int i);

#if defined(GTE_USE_ROW_MAJOR)
        std::array<std::array<Real,NumCols>,NumRows> mStorage;
#else
        std::array<std::array<Real,NumRows>,NumCols> mStorage;
#endif
    };

    Table mTable;
};

// Unary operations.
template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
operator+(Matrix<NumRows,NumCols,Real> const& M);

template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
operator-(Matrix<NumRows,NumCols,Real> const& M);

// Linear-algebraic operations.
template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
operator+(
    Matrix<NumRows,NumCols,Real> const& M0,
    Matrix<NumRows,NumCols,Real> const& M1);

template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
operator-(
    Matrix<NumRows,NumCols,Real> const& M0,
    Matrix<NumRows,NumCols,Real> const& M1);

template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
operator*(Matrix<NumRows,NumCols,Real> const& M, Real scalar);

template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
operator*(Real scalar, Matrix<NumRows,NumCols,Real> const& M);

template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
operator/(Matrix<NumRows,NumCols,Real> const& M, Real scalar);

template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>&
operator+=(
    Matrix<NumRows,NumCols,Real>& M0,
    Matrix<NumRows,NumCols,Real> const& M1);

template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>&
operator-=(
    Matrix<NumRows,NumCols,Real>& M0,
    Matrix<NumRows,NumCols,Real> const& M1);

template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>&
operator*=(Matrix<NumRows,NumCols,Real>& M, Real scalar);

template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>&
operator/=(Matrix<NumRows,NumCols,Real>& M, Real scalar);

// Geometric operations.
template <int NumRows, int NumCols, typename Real>
Real L1Norm(Matrix<NumRows,NumCols,Real> const& M);

template <int NumRows, int NumCols, typename Real>
Real L2Norm(Matrix<NumRows,NumCols,Real> const& M);

template <int NumRows, int NumCols, typename Real>
Real LInfinityNorm(Matrix<NumRows,NumCols,Real> const& M);

template <int N, typename Real>
Matrix<N,N,Real> Inverse(Matrix<N,N,Real> const& M,
    bool* reportInvertibility = nullptr);

template <int N, typename Real>
Real Determinant(Matrix<N, N, Real> const& M);

// M^T
template <int NumRows, int NumCols, typename Real>
Matrix<NumCols,NumRows,Real>
Transpose(Matrix<NumRows,NumCols,Real> const& M);

// M*V
template <int NumRows, int NumCols, typename Real>
Vector<NumRows,Real>
operator*(
    Matrix<NumRows,NumCols,Real> const& M,
    Vector<NumCols,Real> const& V);

// V^T*M
template <int NumRows, int NumCols, typename Real>
Vector<NumCols,Real>
operator*(
    Vector<NumRows,Real> const& V,
    Matrix<NumRows,NumCols,Real> const& M);

// A*B
template <int NumRows, int NumCols, int NumCommon, typename Real>
Matrix<NumRows,NumCols,Real>
operator*(
    Matrix<NumRows,NumCommon,Real> const& A,
    Matrix<NumCommon,NumCols,Real> const& B);

template <int NumRows, int NumCols, int NumCommon, typename Real>
Matrix<NumRows,NumCols,Real>
MultiplyAB(
    Matrix<NumRows,NumCommon,Real> const& A,
    Matrix<NumCommon,NumCols,Real> const& B);

// A*B^T
template <int NumRows, int NumCols, int NumCommon, typename Real>
Matrix<NumRows,NumCols,Real>
MultiplyABT(
    Matrix<NumRows,NumCommon,Real> const& A,
    Matrix<NumCols,NumCommon,Real> const& B);

// A^T*B
template <int NumRows, int NumCols, int NumCommon, typename Real>
Matrix<NumRows,NumCols,Real>
MultiplyATB(
    Matrix<NumCommon,NumRows,Real> const& A,
    Matrix<NumCommon,NumCols,Real> const& B);

// A^T*B^T
template <int NumRows, int NumCols, int NumCommon, typename Real>
Matrix<NumRows,NumCols,Real>
MultiplyATBT(
    Matrix<NumCommon,NumRows,Real> const& A,
    Matrix<NumCols,NumCommon,Real> const& B);

// M*D, D is diagonal NumCols-by-NumCols
template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
MultiplyMD(
    Matrix<NumRows,NumCols,Real> const& M,
    Vector<NumCols,Real> const& D);

// D*M, D is diagonal NumRows-by-NumRows
template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
MultiplyDM(
    Vector<NumRows,Real> const& D,
    Matrix<NumRows,NumCols,Real> const& M);

// U*V^T, U is NumRows-by-1, V is Num-Cols-by-1, result is NumRows-by-NumCols.
template <int NumRows, int NumCols, typename Real>
Matrix<NumRows,NumCols,Real>
OuterProduct(Vector<NumRows, Real> const& U, Vector<NumCols, Real> const& V);

// Initialization to the identity matrix.
template <int N, typename Real>
void MakeIdentity(Matrix<N,N,Real>& M);

// Initialization to a diagonal matrix whose diagonal entries are the
// components of D.
template <int N, typename Real>
void MakeDiagonal(Vector<N, Real> const& D, Matrix<N, N, Real>& M);

#include "GteMatrix.inl"

}
