// Geometric Tools LLC, Redmond WA 98052
// Copyright (c) 1998-2014
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt
// http://www.geometrictools.com/License/Boost/LICENSE_1_0.txt
// File Version: 1.0.0 (2014/08/11)

#pragma once

#include "GteGVector.h"
#include "GteGaussianElimination.h"
#include "GteLogger.h"

// Uncomment these to test for size mismatches that are wrapped by
// GMatrix::ValidateIndices and GMatrix::ValidateSize.  If the test is not
// enabled, the compiler should not generate any code for these functions
// in a release build.
//#define GTE_ASSERT_ON_GMATRIX_INDEX_OUT_OF_RANGE
//#define GTE_ASSERT_ON_GMATRIX_SIZE_MISMATCH

namespace gte
{

template <typename Real>
class GMatrix
{
public:
    // Construction and destruction.  The default constructor does not
    // initialize its data.  The copy constructor, destructor, and assignment
    // operators are generated by the compiler.
    GMatrix(int numRows = 0, int numCols = 0);

    // Create special matrices.
    void MakeZero();  // All components are 0.

    // Member access for which the storage representation is transparent.  The
    // matrix entry in row r and column c is A(r,c).  The first operator()
    // returns a const reference rather than a Real value.  This supports
    // writing via standard file operations that require a const pointer to
    // data.
    void SetSize(int numRows, int numCols);
    inline void GetSize(int& numRows, int& numCols) const;
    inline int GetNumRows() const;
    inline int GetNumCols() const;
    inline int GetNumElements() const;
    inline Real const& operator()(int r, int c) const;
    inline Real& operator()(int r, int c);

    // Member access by rows or by columns.  The input vectors must have the
    // correct number of elements for the matrix size.
    void SetRow(int r, GVector<Real> const& vec);
    void SetCol(int c, GVector<Real> const& vec);
    GVector<Real> GetRow(int r) const;
    GVector<Real> GetCol(int c) const;

    // Member access by 1-dimensional index.  NOTE: These accessors are
    // useful for the manipulation of matrix entries when it does not
    // matter whether storage is row-major or column-major.  Do not use
    // constructs such as M[c+NumCols*r] or M[r+NumRows*c] that expose the
    // storage convention.
    inline Real const& operator[](int i) const;
    inline Real& operator[](int i);

    // Comparisons for sorted containers and geometric ordering.
    bool operator==(GMatrix const& mat) const;
    bool operator!=(GMatrix const& mat) const;
    bool operator< (GMatrix const& mat) const;
    bool operator<=(GMatrix const& mat) const;
    bool operator> (GMatrix const& mat) const;
    bool operator>=(GMatrix const& mat) const;

    // Special matrices.
    static GMatrix Zero(int numRows, int numCols);

protected:
    // The matrix is stored as a 1-dimensional array.  The convention of
    // row-major or column-major is your choice.
    int mNumRows, mNumCols;
    std::vector<Real> mElements;

public:
    // Test for valid indices and sizes.  When the conditional defines used
    // in these functions are not active, the compiler should optimize these
    // to no-operations.
    inline void ValidateIndices(int r, int c) const;
    inline void ValidateSizes(GMatrix const& mat) const;
};

// Unary operations.
template <typename Real>
GMatrix<Real> operator+(GMatrix<Real> const& M);

template <typename Real>
GMatrix<Real> operator-(GMatrix<Real> const& M);

// Linear-algebraic operations.
template <typename Real>
GMatrix<Real> operator+(GMatrix<Real> const& M0, GMatrix<Real> const& M1);

template <typename Real>
GMatrix<Real> operator-(GMatrix<Real> const& M0, GMatrix<Real> const& M1);

template <typename Real>
GMatrix<Real> operator*(GMatrix<Real> const& M, Real scalar);

template <typename Real>
GMatrix<Real> operator*(Real scalar, GMatrix<Real> const& M);

template <typename Real>
GMatrix<Real> operator/(GMatrix<Real> const& M, Real scalar);

template <typename Real>
GMatrix<Real>& operator+=(GMatrix<Real>& M0, GMatrix<Real> const& M1);

template <typename Real>
GMatrix<Real>& operator-=(GMatrix<Real>& M0, GMatrix<Real> const& M1);

template <typename Real>
GMatrix<Real>& operator*=(GMatrix<Real>& M, Real scalar);

template <typename Real>
GMatrix<Real>& operator/=(GMatrix<Real>& M, Real scalar);

// Geometric operations.
template <typename Real>
Real L1Norm(GMatrix<Real> const& M);

template <typename Real>
Real L2Norm(GMatrix<Real> const& M);

template <typename Real>
Real LInfinityNorm(GMatrix<Real> const& M);

template <typename Real>
GMatrix<Real> Inverse(GMatrix<Real> const& M,
    bool* reportInvertibility = nullptr);

template <typename Real>
Real Determinant(GMatrix<Real> const& M);

// M^T
template <typename Real>
GMatrix<Real> Transpose(GMatrix<Real> const& M);

// M*V
template <typename Real>
GVector<Real> operator*(GMatrix<Real> const& M, GVector<Real> const& V);

// V^T*M
template <typename Real>
GVector<Real> operator*(GVector<Real> const& V, GMatrix<Real> const& M);

// A*B
template <typename Real>
GMatrix<Real> operator*(GMatrix<Real> const& A, GMatrix<Real> const& B);

template <typename Real>
GMatrix<Real> MultiplyAB(GMatrix<Real> const& A, GMatrix<Real> const& B);

// A*B^T
template <typename Real>
GMatrix<Real> MultiplyABT(GMatrix<Real> const& A, GMatrix<Real> const& B);

// A^T*B
template <typename Real>
GMatrix<Real> MultiplyATB(GMatrix<Real> const& A, GMatrix<Real> const& B);

// A^T*B^T
template <typename Real>
GMatrix<Real> MultiplyATBT(GMatrix<Real> const& A, GMatrix<Real> const& B);

// M*D, D is square diagonal (stored as vector)
template <typename Real>
GMatrix<Real> MultiplyMD(GMatrix<Real> const& M, GVector<Real> const& D);

// D*M, D is square diagonal (stored as vector)
template <typename Real>
GMatrix<Real> MultiplyDM(GVector<Real> const& D, GMatrix<Real> const& M);

// U*V^T, U is N-by-1, V is M-by-1, result is N-by-M.
template <typename Real>
GMatrix<Real> OuterProduct(GVector<Real> const& U, GVector<Real> const& V);

// Initialization to the identity matrix.
template <typename Real>
void MakeIdentity(GMatrix<Real>& M);

// Initialization to a diagonal matrix whose diagonal entries are the
// components of D.
template <typename Real>
void MakeDiagonal(GVector<Real> const& D, GMatrix<Real>& M);

#include "GteGMatrix.inl"

}
